// Copyright 2021 The Embedded Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

// 9font.go translates Plan 9 bitmap font to the Go source.
//
// Usage: go run 9font.go NAME SIZE FONT_FILE
package main

import (
	"bufio"
	"fmt"
	"image"
	"image/draw"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/embeddedgo/display/pixdisp"
	"github.com/embeddedgo/display/pixdisp/font/font9"
)

func dieErr(err error) {
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func dieInvalid(what ...interface{}) {
	fmt.Fprintf(os.Stderr, "invalid ")
	for _, w := range what[:len(what)-1] {
		fmt.Fprintf(os.Stderr, "%v: ", w)
	}
	fmt.Fprintln(os.Stderr, what[len(what)-1])
	os.Exit(1)
}

func printPackageHeader(w io.Writer, pkgName string) {
	fmt.Fprintf(w, "// DO NOT EDIT\n")
	fmt.Fprintf(w, "// Generated by: go run 9font.go %s\n\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(w, "package %s\n", pkgName)
}

func printSubfontHeader(w io.Writer, name string, first, last uint64, size int) {
	fmt.Fprintf(w, "\n// %s subfont, %d runes: %#04x..%#04x, %d bytes\n", name, last-first+1, first, last, size)
	fmt.Fprintf(w, "var %s = font.Subfont{\n", name)
	fmt.Fprintf(w, "	First: %d,\n", first)
	fmt.Fprintf(w, "	Last:  %d,\n", last)
}

func printString(w io.Writer, name, data string) {
	fmt.Fprintf(w, "\nconst %s = \"", name)
	for i := 0; i < len(data); i++ {
		fmt.Fprintf(w, "\\x%02x", data[i])
	}
	fmt.Fprintf(w, "\"\n")
}

func main() {
	if len(os.Args) != 2 {
		fmt.Fprintln(os.Stderr, "Usage: go run 9font.go FONT_FILE\n")
		os.Exit(1)
	}
	fontFile := os.Args[1]
	fontName := filepath.Base(filepath.Dir(fontFile))
	fontSize := strings.TrimSuffix(filepath.Base(fontFile), ".font")
	fontSize = filepath.Ext(fontSize)
	fontFace := fontName
	if len(fontSize) == 2 {
		fontFace += "_0" + fontSize[1:]
	} else if len(fontSize) > 2 {
		fontFace += "_" + fontSize[1:]
	}

	var fontHeight, fontAscent uint64

	f, err := os.Open(fontFile)
	dieErr(err)
	scan := bufio.NewScanner(f)
	if scan.Scan() {
		split := strings.Fields(scan.Text())
		if len(split) != 2 {
			dieInvalid("font", "header", split)
		}
		fontHeight, err = strconv.ParseUint(split[0], 0, 16)
		if err != nil {
			dieInvalid("font", "header", "height", split[0], err)
		}
		fontAscent, err = strconv.ParseUint(split[1], 0, 16)
		if err != nil {
			dieInvalid("font", "header", "ascent", split[1], err)
		}
	}
	dieErr(scan.Err())

	dieErr(os.Mkdir(fontFace, 0755))
	w, err := os.Create(filepath.Join(fontFace, "subfonts.go"))
	dieErr(err)
	defer w.Close()
	ws, err := os.Create(filepath.Join(fontFace, "strings.go"))
	dieErr(err)
	defer ws.Close()

	printPackageHeader(w, fontFace)
	printPackageHeader(ws, fontFace)
	fmt.Fprintf(w, "\nimport (\n")
	fmt.Fprintf(w, "	\"image\"\n\n")
	fmt.Fprintf(w, "	\"github.com/embeddedgo/display/pixdisp\"\n")
	fmt.Fprintf(w, "	\"github.com/embeddedgo/display/pixdisp/font\"\n")
	fmt.Fprintf(w, "	\"github.com/embeddedgo/display/pixdisp/font/font9\"\n")
	fmt.Fprintf(w, ")\n\n")
	fmt.Fprintf(w, "const (\n")
	fmt.Fprintf(w, "	Height = %d\n", fontHeight)
	fmt.Fprintf(w, "	Ascent = %d\n", fontAscent)
	fmt.Fprintf(w, ")\n")

	dir := filepath.Dir(fontFile)
	for scan.Scan() {
		split := strings.Fields(scan.Text())
		if len(split) != 3 && len(split) != 4 {
			dieInvalid("font", "row", split)
		}

		var first, last, offset uint64

		first, err = strconv.ParseUint(split[0], 0, 32)
		if err != nil {
			dieInvalid(fontFile, "font row", "first", split[0], err)
		}
		last, err = strconv.ParseUint(split[1], 0, 32)
		if err != nil {
			dieInvalid(fontFile, "font row", "last", split[1], err)
		}
		if len(split) == 4 {
			offset, err = strconv.ParseUint(split[2], 0, 32)
			if err != nil {
				dieInvalid(fontFile, "font row", "offset", split[2], err)
			}
			if offset != 0 {
				fmt.Fprintln(os.Stderr, "ignored subfont with non-zero offset:", split)
				continue
			}
		}
		subfont := filepath.Join(dir, split[len(split)-1])
		sf, err := os.Open(subfont)
		if os.IsNotExist(err) {
			sf, err = os.Open(subfont + ".0")
		}
		dieErr(err)

		dirSplit := strings.Split(dir, "/")
		subfontSplit := strings.Split(strings.TrimSuffix(subfont, fontSize), "/")
		name := ""
		for i, s := range subfontSplit {
			if i >= len(dirSplit) || s != dirSplit[i] {
				s = strings.ReplaceAll(s, ".", "_")
				r, size := utf8.DecodeRuneInString(s)
				name += string(unicode.ToUpper(r)) + s[size:]
			}
		}

		data, err := font9.Load(sf)
		dieErr(err)

		var img *pixdisp.Alpha1
		switch d := data.(type) {
		case *font9.Variable:
			optimizeVariable(d)
			img = d.Bits.(*pixdisp.Alpha1)
			printSubfontHeader(w, name, first, last, 16+len(d.Info)+32+len(img.Pix))
			fmt.Fprintf(w, "	Data: &font9.Variable{\n")
			fmt.Fprintf(w, "		Info: info%s, // %d bytes\n", name, len(d.Info))
			fmt.Fprintf(w, "		Bits: &pixdisp.ImmAlpha1{\n")
		case *font9.Fixed:
			optimizeFixed(d)
			img = d.Bits.(*pixdisp.Alpha1)
			printSubfontHeader(w, name, first, last, 4+8+32+len(img.Pix))
			fmt.Fprintf(w, "	Data: &font9.Fixed{\n")
			fmt.Fprintf(w, "		Left:  %d,\n", d.Left)
			fmt.Fprintf(w, "		Adv:   %d,\n", d.Adv)
			fmt.Fprintf(w, "		Width: %d,\n", d.Width)
			fmt.Fprintf(w, "		Bits:  &pixdisp.ImmAlpha1{\n")
		default:
			dieInvalid(subfont, "data format")
		}
		fmt.Fprintf(w, "			Rect:   image.Rectangle{Max: image.Point{X: %d, Y: %d}},\n", img.Rect.Dx(), img.Rect.Dy())
		fmt.Fprintf(w, "			Stride: %d,\n", img.Stride)
		fmt.Fprintf(w, "			Pix:    pix%s, // %d bytes\n", name, len(img.Pix))
		fmt.Fprintf(w, "		},\n")
		fmt.Fprintf(w, "	},\n")
		fmt.Fprintf(w, "}\n")
		if d, ok := data.(*font9.Variable); ok {
			printString(ws, "info"+name, d.Info)
		}
		printString(ws, "pix"+name, string(img.Pix))
	}
	dieErr(scan.Err())
}

func removeEmptyRows(img font9.Image) font9.Image {
	r := img.Bounds()
top:
	for r.Min.Y < r.Max.Y {
		for x := r.Min.X; x < r.Max.X; x++ {
			if _, _, _, a := img.At(x, r.Min.Y).RGBA(); a != 0 {
				break top
			}
		}
		r.Min.Y++
	}
	img = img.SubImage(r).(font9.Image)
boottom:
	for r.Max.Y > r.Min.Y {
		for x := r.Min.X; x < r.Max.X; x++ {
			if _, _, _, a := img.At(x, r.Max.Y-1).RGBA(); a != 0 {
				break boottom
			}
		}
		r.Max.Y--
	}
	return img.SubImage(r).(font9.Image)
}

func optimizeVariable(d *font9.Variable) {
	d.Bits = removeEmptyRows(d.Bits)

	// remove empty columns

	r := d.Bits.Bounds()
	r.Max.X = r.Dx()
	r.Min.X = 0
	dst := pixdisp.NewAlpha1(r)
	var info strings.Builder
	for i := 0; i < d.Num(); i++ {
		img, origin, advance := d.Glyph(i)
		src := img.(font9.Image)
		sr := src.Bounds()
	left:
		for sr.Min.X < sr.Max.X {
			for y := sr.Min.Y; y < sr.Max.Y; y++ {
				if _, _, _, a := src.At(sr.Min.X, y).RGBA(); a != 0 {
					break left
				}
			}
			sr.Min.X++
		}
	right:
		for sr.Max.X > sr.Min.X {
			for y := sr.Min.Y; y < sr.Max.Y; y++ {
				if _, _, _, a := src.At(sr.Max.X-1, y).RGBA(); a != 0 {
					break right
				}
			}
			sr.Max.X--
		}
		draw.Draw(dst, r, src.SubImage(sr), sr.Min, draw.Src)
		info.WriteByte(uint8(origin.X - sr.Min.X))
		info.WriteByte(uint8(advance))
		r.Min.X += sr.Dx()
	}
	info.WriteByte(uint8(r.Min.X))
	info.WriteByte(uint8(r.Min.X >> 8))
	r.Max.X = r.Min.X
	r.Min.X = 0
	d.Info = info.String()
	d.Bits = dst.SubImage(r).(font9.Image)
}

func optimizeFixed(d *font9.Fixed) {
	d.Bits = removeEmptyRows(d.Bits)

	// remove empty columns

	src := d.Bits
	sr := src.Bounds()
	sw := int(d.Width)
	left := 0
left:
	for {
		for i := 0; i < d.Num(); i++ {
			x := sr.Min.X + i*sw + left
			for y := sr.Min.Y; y < sr.Max.Y; y++ {
				if _, _, _, a := src.At(x, y).RGBA(); a != 0 {
					break left
				}
			}
		}
		left++
	}
	right := 0
right:
	for {
		for i := 1; i <= d.Num(); i++ {
			x := sr.Min.X + i*sw - right - 1
			for y := sr.Min.Y; y < sr.Max.Y; y++ {
				if _, _, _, a := src.At(x, y).RGBA(); a != 0 {
					break right
				}
			}
		}
		right++
	}
	w := sw - (left + right)
	r := sr
	r.Min.X = 0
	r.Max.X = w * d.Num()
	dst := pixdisp.NewAlpha1(r)
	r.Max.X = r.Min.X + w
	for i := 0; i < d.Num(); i++ {
		draw.Draw(dst, r, src.SubImage(sr), sr.Min, draw.Src)
		r.Min.X += w
		r.Max.X += w
		sr.Min.X += sw
	}
	d.Left = int8(int(d.Left) - left)
	d.Width = uint8(w)
	d.Bits = dst
}

func printImg(img image.Image, descr ...interface{}) {
	r := img.Bounds()
	w := r.Dx()
	if w > 318 {
		w = 318
	}
	i, _ := fmt.Printf("- %v %v -", descr, r)
	for ; i < w; i++ {
		fmt.Print("-")
	}
	fmt.Print("\n")
	h := r.Dy()
	min := r.Min
	for y := 0; y < h; y++ {
		for x := 0; x < w; x++ {
			_, _, _, a := img.At(min.X+x, min.Y+y).RGBA()
			if a == 0 {
				fmt.Print(" ")
			} else {
				fmt.Print("#")
			}
		}
		fmt.Println()
	}
	for i := 0; i < w; i++ {
		fmt.Print("-")
	}
	fmt.Print("\n")
}
